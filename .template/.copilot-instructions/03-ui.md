# UI Layer Implementation Instructions

## Overview
Create generic, reusable UI widgets with no state management and no model dependencies.

## Repository
**Target:** Miller9921/flutter-ui-components

## Structure
```
/lib/
  └── [module]/
      ├── widgets/
      │   ├── [widget1].dart
      │   ├── [widget2].dart
      │   └── [widget3].dart
      └── exports.dart
```

## Widgetbook Structure
```
/widgetbook/
  └── [module]/
      └── [widget]_story.dart
```

## 1. Creating Generic Widgets

### Requirements
- Use generic type parameters `<T>`
- Accept callbacks for data extraction
- NO imported models (only primitive types and generics)
- NO state management libraries (only setState if needed)
- Use Theme.of(context) for styling
- Use ClapColors for custom colors
- StatefulWidget when controllers needed

### Generic Widget Template

```dart
import 'package:flutter/material.dart';
import 'package:ui_widgets_clap/core/colors/clap_colors.dart';

class PaymentMethodSelector<T> extends StatelessWidget {
  final List<T> methods;
  final T? selectedMethod;
  final String Function(T) getDisplayName;
  final String Function(T)? getSubtitle;
  final void Function(T) onMethodSelected;
  final bool Function(T)? isEnabled;

  const PaymentMethodSelector({
    Key? key,
    required this.methods,
    this.selectedMethod,
    required this.getDisplayName,
    this.getSubtitle,
    required this.onMethodSelected,
    this.isEnabled,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: methods.length,
      itemBuilder: (context, index) {
        final method = methods[index];
        final isSelected = selectedMethod != null && 
            getDisplayName(selectedMethod!) == getDisplayName(method);
        final enabled = isEnabled?.call(method) ?? true;

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
          elevation: isSelected ? 4 : 1,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: isSelected ? ClapColors.primary : Colors.grey.shade300,
              width: isSelected ? 2 : 1,
            ),
          ),
          child: ListTile(
            enabled: enabled,
            title: Text(
              getDisplayName(method),
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: enabled ? null : Colors.grey,
              ),
            ),
            subtitle: getSubtitle != null
                ? Text(
                    getSubtitle!(method),
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: enabled ? null : Colors.grey,
                    ),
                  )
                : null,
            trailing: isSelected
                ? Icon(
                    Icons.check_circle,
                    color: ClapColors.primary,
                  )
                : null,
            onTap: enabled ? () => onMethodSelected(method) : null,
          ),
        );
      },
    );
  }
}
```

### Key Points
- Generic type `<T>` for flexibility
- Callback functions to extract data from generic type
- Optional parameters for flexibility
- Uses Theme for standard styling
- Uses ClapColors for branded colors
- Null-safe with proper checks

## 2. Stateful Widget with Controllers

### Stateful Widget Template

```dart
import 'package:flutter/material.dart';
import 'package:ui_widgets_clap/core/colors/clap_colors.dart';

class PaymentFormWidget<T> extends StatefulWidget {
  final T? initialData;
  final void Function(double amount, String currency) onSubmit;
  final List<String> availableCurrencies;
  final double? Function(T)? getAmount;
  final String? Function(T)? getCurrency;

  const PaymentFormWidget({
    Key? key,
    this.initialData,
    required this.onSubmit,
    required this.availableCurrencies,
    this.getAmount,
    this.getCurrency,
  }) : super(key: key);

  @override
  State<PaymentFormWidget<T>> createState() => _PaymentFormWidgetState<T>();
}

class _PaymentFormWidgetState<T> extends State<PaymentFormWidget<T>> {
  late final TextEditingController _amountController;
  String _selectedCurrency = 'USD';

  @override
  void initState() {
    super.initState();
    
    // Initialize with existing data if provided
    final initialAmount = widget.initialData != null && widget.getAmount != null
        ? widget.getAmount!(widget.initialData!)
        : null;
    
    _amountController = TextEditingController(
      text: initialAmount?.toString() ?? '',
    );

    if (widget.initialData != null && widget.getCurrency != null) {
      final currency = widget.getCurrency!(widget.initialData!);
      if (currency != null && widget.availableCurrencies.contains(currency)) {
        _selectedCurrency = currency;
      }
    }
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  void _handleSubmit() {
    final amount = double.tryParse(_amountController.text);
    if (amount == null || amount <= 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a valid amount')),
      );
      return;
    }

    widget.onSubmit(amount, _selectedCurrency);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.all(16),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'Payment Amount',
              style: theme.textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _amountController,
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              decoration: InputDecoration(
                labelText: 'Amount',
                prefixText: '\$ ',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide(color: ClapColors.primary, width: 2),
                ),
              ),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _selectedCurrency,
              decoration: InputDecoration(
                labelText: 'Currency',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              items: widget.availableCurrencies.map((currency) {
                return DropdownMenuItem(
                  value: currency,
                  child: Text(currency),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    _selectedCurrency = value;
                  });
                }
              },
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _handleSubmit,
              style: ElevatedButton.styleFrom(
                backgroundColor: ClapColors.primary,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              child: const Text(
                'Submit Payment',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

### Key Points
- Use StatefulWidget when controllers needed
- Initialize controllers in initState
- Dispose controllers in dispose
- Handle form validation locally
- Use callbacks to communicate with parent
- Extract data from generic type using provided functions

## 3. List Widget with Scrolling

### Scrollable List Template

```dart
import 'package:flutter/material.dart';
import 'package:ui_widgets_clap/core/colors/clap_colors.dart';

class PaymentHistoryList<T> extends StatelessWidget {
  final List<T> payments;
  final String Function(T) getTitle;
  final String Function(T) getSubtitle;
  final String Function(T)? getAmount;
  final Widget? Function(T)? getStatusWidget;
  final void Function(T)? onItemTap;
  final String? emptyMessage;

  const PaymentHistoryList({
    Key? key,
    required this.payments,
    required this.getTitle,
    required this.getSubtitle,
    this.getAmount,
    this.getStatusWidget,
    this.onItemTap,
    this.emptyMessage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    if (payments.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.receipt_long_outlined,
              size: 64,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: 16),
            Text(
              emptyMessage ?? 'No payments found',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: Colors.grey.shade600,
              ),
            ),
          ],
        ),
      );
    }

    return ListView.separated(
      itemCount: payments.length,
      separatorBuilder: (context, index) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final payment = payments[index];

        return ListTile(
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          title: Text(
            getTitle(payment),
            style: theme.textTheme.titleMedium,
          ),
          subtitle: Text(
            getSubtitle(payment),
            style: theme.textTheme.bodySmall,
          ),
          trailing: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              if (getAmount != null)
                Text(
                  getAmount!(payment),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: ClapColors.primary,
                  ),
                ),
              if (getStatusWidget != null)
                getStatusWidget!(payment) ?? const SizedBox.shrink(),
            ],
          ),
          onTap: onItemTap != null ? () => onItemTap!(payment) : null,
        );
      },
    );
  }
}
```

## 4. Status Display Widget

### Display Card Template

```dart
import 'package:flutter/material.dart';
import 'package:ui_widgets_clap/core/colors/clap_colors.dart';

class PaymentStatusCard<T> extends StatelessWidget {
  final T payment;
  final String Function(T) getStatus;
  final String Function(T) getAmount;
  final String Function(T) getDate;
  final Color? Function(T)? getStatusColor;
  final IconData? Function(T)? getStatusIcon;
  final void Function(T)? onViewDetails;

  const PaymentStatusCard({
    Key? key,
    required this.payment,
    required this.getStatus,
    required this.getAmount,
    required this.getDate,
    this.getStatusColor,
    this.getStatusIcon,
    this.onViewDetails,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final statusColor = getStatusColor?.call(payment) ?? Colors.grey;
    final statusIcon = getStatusIcon?.call(payment) ?? Icons.info_outline;

    return Card(
      margin: const EdgeInsets.all(16),
      elevation: 3,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: statusColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(
                    statusIcon,
                    color: statusColor,
                    size: 32,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        getStatus(payment),
                        style: theme.textTheme.titleMedium?.copyWith(
                          color: statusColor,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        getDate(payment),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            const Divider(),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Amount',
                  style: theme.textTheme.bodyLarge,
                ),
                Text(
                  getAmount(payment),
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: ClapColors.primary,
                  ),
                ),
              ],
            ),
            if (onViewDetails != null) ...[
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: OutlinedButton(
                  onPressed: () => onViewDetails!(payment),
                  style: OutlinedButton.styleFrom(
                    side: BorderSide(color: ClapColors.primary),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  child: Text(
                    'View Details',
                    style: TextStyle(color: ClapColors.primary),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
```

## 5. Widgetbook Stories

### Widgetbook Story Template

```dart
import 'package:flutter/material.dart';
import 'package:widgetbook_annotation/widgetbook_annotation.dart';
import 'package:ui_widgets_clap/payment/widgets/payment_method_selector.dart';

@UseCase(
  name: 'Default',
  type: PaymentMethodSelector,
)
Widget paymentMethodSelectorDefault(BuildContext context) {
  return Scaffold(
    body: PaymentMethodSelector<_MockPaymentMethod>(
      methods: _mockPaymentMethods,
      selectedMethod: _mockPaymentMethods[0],
      getDisplayName: (method) => method.name,
      getSubtitle: (method) => method.details,
      onMethodSelected: (method) {
        print('Selected: ${method.name}');
      },
      isEnabled: (method) => method.isAvailable,
    ),
  );
}

@UseCase(
  name: 'Empty List',
  type: PaymentMethodSelector,
)
Widget paymentMethodSelectorEmpty(BuildContext context) {
  return Scaffold(
    body: PaymentMethodSelector<_MockPaymentMethod>(
      methods: [],
      getDisplayName: (method) => method.name,
      onMethodSelected: (method) {},
    ),
  );
}

// Mock data for preview
class _MockPaymentMethod {
  final String name;
  final String details;
  final bool isAvailable;

  _MockPaymentMethod(this.name, this.details, this.isAvailable);
}

final _mockPaymentMethods = [
  _MockPaymentMethod('Credit Card', '**** 1234', true),
  _MockPaymentMethod('PayPal', 'user@example.com', true),
  _MockPaymentMethod('Bank Transfer', 'Not configured', false),
];
```

## 6. Creating Exports File

### exports.dart

```dart
export 'widgets/payment_method_selector.dart';
export 'widgets/payment_form_widget.dart';
export 'widgets/payment_history_list.dart';
export 'widgets/payment_status_card.dart';
```

## Important Rules

### ✅ DO
- Use generic type parameters `<T>`
- Accept callback functions for data extraction
- Use Theme.of(context) for theming
- Use ClapColors for branded colors
- Create Widgetbook stories for all widgets
- Handle edge cases (empty lists, null values)
- Use proper null safety
- Make widgets reusable and flexible

### ❌ DON'T
- DON'T import domain models
- DON'T import infrastructure code
- DON'T use state management libraries (BLoC, Provider, etc.)
- DON'T make API calls
- DON'T include business logic
- DON'T use hard-coded strings that should be i18n
- DON'T use specific types when generic works

## Naming Conventions

- **Widgets:** `[Purpose]Widget<T>` or `[Purpose]<T>` (e.g., PaymentFormWidget, PaymentMethodSelector)
- **Files:** snake_case (e.g., payment_form_widget.dart)
- **Callback parameters:** Descriptive names (getDisplayName, onItemSelected)

## Color Usage

```dart
// Primary color
ClapColors.primary

// Success
ClapColors.success

// Error
ClapColors.error

// Warning
ClapColors.warning

// Use Theme for standard colors
Theme.of(context).colorScheme.primary
Theme.of(context).colorScheme.error
```

## Dependencies

```yaml
dependencies:
  flutter:
    sdk: flutter
  ui_widgets_clap:
    path: ../flutter-ui-core

dev_dependencies:
  widgetbook: ^3.0.0
  widgetbook_annotation: ^3.0.0
```

## Testing Considerations

- Widget tests for different states
- Golden tests for visual regression
- Interaction tests for user actions
- Test with different data scenarios

---

**Follow these patterns exactly for consistent UI layer implementation across the CLAP architecture.**
